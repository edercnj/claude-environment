# Global Behavior & Language Policy
- **Output Language**: English ONLY. (Mandatory for all responses and internal reasoning).
- **Token Optimization**: Eliminate all greetings, apologies, and conversational fluff. Start responses directly with technical information.
- **Priority**: Maintain 100% fidelity to the technical constraints defined in the original rules below.

# Rule 17 — REST API Design

## Principles
- **RESTEasy Reactive** (JAX-RS) via Quarkus
- **JSON** with Jackson for serialization
- **OpenAPI 3.0** for documentation (auto-generated by Quarkus)
- **Versioning** in URL: `/api/v1/`

## URL Structure
```
/api/v1/{resource}              → collection
/api/v1/{resource}/{id}         → specific resource
/api/v1/{resource}/{id}/{sub}   → sub-resource
```

### Project Endpoints
```
# Merchants
GET    /api/v1/merchants                    → List merchants
POST   /api/v1/merchants                    → Create merchant
GET    /api/v1/merchants/{id}               → Get merchant by ID
PUT    /api/v1/merchants/{id}               → Update merchant
DELETE /api/v1/merchants/{id}               → Deactivate merchant (soft delete)

# Terminals (sub-resource of Merchant)
GET    /api/v1/merchants/{id}/terminals     → List merchant terminals
POST   /api/v1/merchants/{id}/terminals     → Create terminal
GET    /api/v1/terminals/{tid}              → Get terminal by TID
PUT    /api/v1/terminals/{tid}              → Update terminal

# Transactions (read-only, dashboard)
GET    /api/v1/transactions                 → List transactions (with filters)
GET    /api/v1/transactions/{id}            → Transaction detail
GET    /api/v1/transactions/summary         → Summary/totals

# Health (Quarkus built-in)
GET    /q/health                            → Overall health
GET    /q/health/live                       → Liveness
GET    /q/health/ready                      → Readiness
GET    /q/metrics                           → OpenTelemetry metrics
```

## Status Codes
| Operation | Success | Common Errors |
|-----------|---------|---------------|
| GET list | 200 OK | 400 Bad Request (invalid filter) |
| GET item | 200 OK | 404 Not Found |
| POST | 201 Created (with Location header) | 400 Validation, 409 Conflict (duplicate) |
| PUT | 200 OK | 400 Validation, 404 Not Found |
| DELETE | 204 No Content | 404 Not Found |
| Rate Limited | — | 429 Too Many Requests + `Retry-After` (Rule 24) |
| Circuit Open / Degraded | — | 503 Service Unavailable + `Retry-After` (Rule 24) |

## Request/Response DTOs (Records)
```java
// ✅ Request — with validation
@RegisterForReflection
public record CreateMerchantRequest(
    @NotBlank @Size(max = 15) String mid,
    @NotBlank @Size(max = 100) String name,
    @NotBlank @Size(min = 11, max = 14) String document,
    @NotBlank @Size(min = 4, max = 4) String mcc,
    boolean timeoutEnabled
) {}

// ✅ Response — immutable, no sensitive data
@RegisterForReflection
public record MerchantResponse(
    Long id,
    String mid,
    String name,
    String documentMasked,  // masked CNPJ
    String mcc,
    boolean timeoutEnabled,
    String status,
    OffsetDateTime createdAt
) {}
```

## Standardized Error Response (RFC 7807)
```java
@RegisterForReflection
public record ProblemDetail(
    String type,        // error type URI
    String title,       // readable title
    int status,         // HTTP status code
    String detail,      // detailed description
    String instance,    // error instance URI
    Map<String, Object> extensions  // additional fields
) {}
```

Example error response:
```json
{
  "type": "/errors/merchant-already-exists",
  "title": "Merchant Already Exists",
  "status": 409,
  "detail": "A merchant with MID '123456789012345' already exists",
  "instance": "/api/v1/merchants",
  "extensions": {
    "existingMid": "123456789012345"
  }
}
```

## Pagination
```json
{
  "data": [...],
  "pagination": {
    "page": 1,
    "limit": 20,
    "total": 150,
    "totalPages": 8
  }
}
```
Query params: `?page=1&limit=20&sort=createdAt,desc`

## Filters (Transactions)
```
GET /api/v1/transactions?mti=1200&rc=00&from=2026-02-01&to=2026-02-15&mid=123&limit=50
```

## JSON Serialization
- Dates: ISO 8601 (`2026-02-16T14:30:00Z`)
- Fields: camelCase in JSON, snake_case in database
- Nulls: omit null fields (Jackson `@JsonInclude(NON_NULL)`)
- Enums: serialize as string (`"APPROVED"`, not `0`)

## Security
- Authentication: API Key via `X-API-Key` header
- PAN: NEVER expose full in responses
- Rate limiting: configurable per API Key
- CORS: configure for frontend if needed

## ExceptionMapper — Mandatory (Dual) Pattern

The project uses **two complementary ExceptionMappers** for REST error handling:

### SimulatorExceptionMapper — Domain Exceptions

Maps domain exceptions to RFC 7807 responses using **pattern matching switch**:

```java
@Provider
public class SimulatorExceptionMapper implements ExceptionMapper<RuntimeException> {

    @Context
    UriInfo uriInfo;

    @Override
    public Response toResponse(RuntimeException exception) {
        var problemDetail = switch (exception) {
            case MerchantNotFoundException e -> ProblemDetail.notFound(
                "Merchant not found: " + e.getIdentifier(), uriInfo.getPath());
            case MerchantAlreadyExistsException e -> ProblemDetail.conflict(
                "Merchant with MID '%s' already exists".formatted(e.getMid()),
                uriInfo.getPath(), Map.of("existingMid", e.getMid()));
            case TerminalNotFoundException e -> ProblemDetail.notFound(
                "Terminal not found: " + e.getIdentifier(), uriInfo.getPath());
            case TerminalAlreadyExistsException e -> ProblemDetail.conflict(
                "Terminal with TID '%s' already exists".formatted(e.getTid()),
                uriInfo.getPath(), Map.of("existingTid", e.getTid()));
            case InvalidDocumentException e -> ProblemDetail.badRequest(
                e.getMessage(), uriInfo.getPath());
            default -> {
                LOG.errorf("Unexpected error on %s: %s", uriInfo.getPath(), exception.getMessage());
                yield ProblemDetail.internalError("Internal processing error", uriInfo.getPath());
            }
        };
        return Response.status(problemDetail.status()).entity(problemDetail).build();
    }
}
```

### ConstraintViolationExceptionMapper — Bean Validation

Extracts violations field by field from `ConstraintViolationException`:

```java
@Provider
public class ConstraintViolationExceptionMapper implements ExceptionMapper<ConstraintViolationException> {

    @Context
    UriInfo uriInfo;

    @Override
    public Response toResponse(ConstraintViolationException exception) {
        var violations = exception.getConstraintViolations().stream()
            .collect(Collectors.groupingBy(
                v -> extractFieldName(v.getPropertyPath()),
                Collectors.mapping(ConstraintViolation::getMessage, Collectors.toList())
            ));
        var problemDetail = ProblemDetail.validationError(
            "Validation failed", uriInfo.getPath(), violations);
        return Response.status(400).entity(problemDetail).build();
    }
}
```

**Rules:**
- ALWAYS use pattern matching switch (Java 21) in `SimulatorExceptionMapper`
- Each new domain exception MUST have a corresponding `case`
- The `default` MUST log at ERROR level and return 500 generic (never expose stack trace)
- `ConstraintViolationExceptionMapper` groups violations by field for easier frontend display

## ProblemDetail — Factory Methods

The `ProblemDetail` record has factory methods for each error type, centralizing creation:

```java
@RegisterForReflection
@JsonInclude(JsonInclude.Include.NON_NULL)
public record ProblemDetail(
    String type, String title, int status, String detail,
    String instance, Map<String, Object> extensions
) {
    public static ProblemDetail notFound(String detail, String instance) {
        return new ProblemDetail("/errors/not-found", "Not Found", 404, detail, instance, null);
    }

    public static ProblemDetail conflict(String detail, String instance, Map<String, Object> extensions) {
        return new ProblemDetail("/errors/conflict", "Conflict", 409, detail, instance, extensions);
    }

    public static ProblemDetail badRequest(String detail, String instance) {
        return new ProblemDetail("/errors/bad-request", "Bad Request", 400, detail, instance, null);
    }

    public static ProblemDetail validationError(String detail, String instance, Map<String, List<String>> violations) {
        return new ProblemDetail("/errors/validation-error", "Validation Error", 400, detail, instance,
            Map.of("violations", violations));
    }

    public static ProblemDetail internalError(String detail, String instance) {
        return new ProblemDetail("/errors/internal-error", "Internal Server Error", 500, detail, instance, null);
    }
}
```

**Rules:**
- Each new error type (status code) MUST have a corresponding factory method
- NEVER construct `ProblemDetail` directly with `new` — use factory methods
- The `type` field follows the pattern `/errors/{error-slug}`

## PaginatedResponse\<T\> — Generic Wrapper

All paginated listings use the `PaginatedResponse<T>` wrapper:

```java
@RegisterForReflection
@JsonInclude(JsonInclude.Include.NON_NULL)
public record PaginatedResponse<T>(
    List<T> data,
    PaginationInfo pagination
) {
    @RegisterForReflection
    public record PaginationInfo(int page, int limit, long total, int totalPages) {}

    public static <T> PaginatedResponse<T> of(List<T> data, int page, int limit, long total) {
        int totalPages = (int) Math.ceil((double) total / limit);
        return new PaginatedResponse<>(data, new PaginationInfo(page, limit, total, totalPages));
    }
}
```

**Usage in Resource:**
```java
@GET
public PaginatedResponse<MerchantResponse> list(
        @QueryParam("page") @DefaultValue("0") int page,
        @QueryParam("limit") @DefaultValue("20") int limit) {
    var merchants = service.listMerchants(page, limit);
    var total = service.countMerchants();
    var responses = merchants.stream().map(MerchantDtoMapper::toResponse).toList();
    return PaginatedResponse.of(responses, page, limit, total);
}
```

**Rules:**
- `page` is **0-based** internally (Panache standard)
- ALWAYS use factory method `PaginatedResponse.of()` to create instances
- `PaginationInfo` is a nested record — MUST have `@RegisterForReflection` separately

## OpenAPI @Schema — Mandatory Annotations

All REST DTOs MUST have `@Schema` annotations from MicroProfile OpenAPI:

```java
@RegisterForReflection
@Schema(description = "Request for merchant creation")
public record CreateMerchantRequest(
    @NotBlank @Size(max = 15)
    @Schema(description = "Merchant Identifier (MID)", example = "123456789012345", maxLength = 15)
    String mid,

    @NotBlank @Size(max = 100)
    @Schema(description = "Merchant legal name", example = "Test Store LTDA", maxLength = 100)
    String name,

    @NotBlank @Size(min = 11, max = 14) @Pattern(regexp = "\\d{11,14}")
    @Schema(description = "CPF (11 digits) or CNPJ (14 digits)", example = "12345678000190")
    String document,

    @NotBlank @Size(min = 4, max = 4) @Pattern(regexp = "\\d{4}")
    @Schema(description = "Merchant Category Code", example = "5411")
    String mcc
) {}
```

**Rules:**
- `@Schema` on **class** with `description`
- `@Schema` on **each field** with `description` and `example`
- Nested records ALSO must have `@Schema` on class and fields
- `example` should contain realistic and valid value
- Do not use `@Schema` on internal fields that don't appear in the API

## Resilience in REST API (Rule 24)

For rate limiting, circuit breaker, timeout and fallback on REST endpoints, follow **Rule 24 — Application Resilience**:
- Rate limit via JAX-RS `ContainerRequestFilter` (Bucket4j) → 429 response
- Circuit breaker open → 503 response with `Retry-After`
- Fault tolerance exceptions (`CircuitBreakerOpenException`, `TimeoutException`, `BulkheadException`) MUST be mapped in `SimulatorExceptionMapper`
- `ProblemDetail` MUST have factory methods for `tooManyRequests()` and `serviceUnavailable()`

## Anti-Patterns
- ❌ Verbs in URL (`/api/v1/createMerchant`) → use nouns + HTTP verb
- ❌ Return 200 for errors with `{ "error": true }` → use HTTP status codes
- ❌ Expose JPA Entity directly → ALWAYS use DTOs (Records)
- ❌ Return lists without pagination → ALWAYS paginate
- ❌ Ignore Content-Type → ALWAYS validate `application/json`
- ❌ Construct `ProblemDetail` directly with `new` → use factory methods
- ❌ ExceptionMapper without log in `default` → unexpected errors must be logged
- ❌ REST DTOs without `@Schema` → incomplete OpenAPI documentation
