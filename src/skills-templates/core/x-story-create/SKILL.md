---
name: x-story-create
description: >
  Generate detailed User Story files from an Epic and system specification. This skill reads an
  Epic file (with its story index and rules table) and the original system spec, then produces
  one file per story with full data contracts, Gherkin acceptance criteria, Mermaid sequence
  diagrams, dependency declarations, and tagged sub-tasks. Use this skill whenever the user asks
  to create stories, generate user stories from an epic, detail stories with acceptance criteria,
  write Gherkin scenarios for a spec, create story files with data contracts, or any variation
  of "generate stories from this epic/spec". Also trigger when the user mentions writing acceptance
  criteria, detailing technical stories, creating story files with contracts and diagrams, or
  breaking an epic into implementable stories — even if they don't use the word "story" explicitly.
---

# Create Stories from Epic and System Specification

This skill generates individual story files — the implementable work items that developers
pick up and build. Each story is self-contained: a developer should be able to implement it
without going back to the original spec.

## Why Self-Contained Stories Matter

A story that says "implement the main operation" is useless without the data contract,
the field mappings, the validation rules, and the error codes. Developers shouldn't
need to context-switch between the story and the spec. The story IS the spec for that slice
of work — precise, testable, and complete.

## Prerequisites

Read the following files before starting:

**Template (output structure):**
- `.claude/templates/_TEMPLATE-STORY.md` — The exact structure to follow

**Decomposition philosophy (sizing and boundary heuristics):**
- `.claude/skills/x-story-epic-full/references/decomposition-guide.md`

**Required inputs from the user:**
- The system specification file (original spec)
- The Epic file (with story index and rules table) — generated by `x-story-epic` skill

## Workflow

### Step 1: Read the Epic and Spec

Read both files completely. From the Epic, extract:
- The story index (IDs, titles, dependencies)
- The rules table (RULE-001..N) — stories will reference these by ID
- The DoD (copied into each story for quick reference)

From the spec, understand the full technical context: journeys, data contracts, protocol
mappings, state machines, error codes, metrics.

### Step 2: Generate Each Story

For each story in the Epic's index, create a file following `_TEMPLATE-STORY.md`. Process
stories in dependency order (foundations first, then core, then extensions).

#### Section 1 — Dependências

| Blocked By | Blocks |
| :--- | :--- |
| Stories this one depends on | Stories that depend on this one |

Must be consistent with the Epic's index. Cross-check: if STORY-003 lists STORY-002 as
blocker, then STORY-002 must list STORY-003 in its Blocks column.

#### Section 2 — Regras Transversais Aplicáveis

Reference only the rules from the Epic that impact this specific story. Don't list rules
that are irrelevant to this story's scope.

#### Section 3 — Descrição

Start with user story format: "Como **<Persona>**, eu quero <capability>, garantindo que <outcome>."

Follow with 2-3 paragraphs of technical context: why this story exists, how it fits in the
epic, what architectural patterns it establishes or reuses. Include specific protocol details,
component names, and design decisions from the spec.

Add numbered subsections (3.1, 3.2, ...) for each distinct technical requirement. Be specific:
protocol details, framing formats, concurrency requirements, timeout values — everything a
developer needs.

#### Section 4 — Definições de Qualidade Locais

**DoR Local**: Specific preconditions for this story. Use checkboxes `- [ ]`.
Examples: "Porta TCP definida", "Schema da tabela X criado", "Decisão sobre Y tomada".

**DoD Local**: Specific acceptance criteria for this story. Use checkboxes.
Examples: "Servidor TCP aceitando conexões", "Handler X funcional", "Teste de carga validado".

**DoD Global**: Copy from the Epic verbatim. This is for quick reference during code review.

#### Section 5 — Contratos de Dados (Data Contract)

This is the most critical section. Data contracts must be copy-paste precise.

For protocol-based stories (binary protocols, gRPC, etc.), use the format:

| Campo | Formato | Request | Response | Origem / Regra |
| :--- | :--- | :--- | :--- | :--- |
| `field_name` | type format | M/O/- | M/O/- | Generate/Echo/Derive — description |

For REST-based stories, use:

| Campo | Tipo | Obrigatório | Descrição |
| :--- | :--- | :--- | :--- |
| `field_name` | type | Sim/Não/Condicional | description |

**Precision rules:**
- Field names must match the spec exactly (same casing, same naming)
- Types must include format details (n 6, LLVAR z..37, VARCHAR(64))
- M/O flags must reflect the actual contract, not guesses
- Derivation rules must explain exactly how values are computed

#### Section 6 — Diagramas

Create Mermaid sequence diagrams showing the complete flow for this story's main operation.
Use the actual component names from the spec (not generic "Service A", "Service B").

Include:
- The trigger (client request, Kafka event, timer)
- Validation steps
- Business logic (decision engine, routing)
- Persistence (DB writes, cache updates)
- Async operations (Kafka publish, logging)
- Response construction
- Error paths (at least one error scenario)

#### Section 7 — Critérios de Aceite (Gherkin)

Write Gherkin scenarios in Portuguese (DADO/QUANDO/ENTÃO/E/MAS).

**Required scenarios:**
1. **Happy path**: The main success flow with concrete values
2. **Business rule violation**: At least one rule from Section 2 being enforced
3. **Malformed input**: Invalid data handling (wrong format, missing fields)
4. **Edge case**: Concurrency, timeout, boundary values — whatever is most relevant

**Quality rules for Gherkin:**
- Use concrete values, not abstractions ("valor de R$ 100,50" not "um valor qualquer")
- Each scenario should be independently testable
- Avoid overlapping scenarios — each tests a distinct behavior
- Include field-level assertions ("o campo DE 39 deve ser '00'")

#### Section 8 — Sub-tarefas

Break the story into granular tasks, each estimable at 2-4 hours:

- `[Dev]` — Implementation tasks (handler, service, repository, migration)
- `[Test]` — Test tasks (unit, integration, E2E, performance)
- `[Doc]` — Documentation tasks (diagrams, wiki, API docs)

Use checkboxes `- [ ]` for tracking.

### Step 3: Save and Report

Save each story as `STORY-NNN.md` in the same directory as the Epic.
Report: total stories generated, dependency graph summary, any inconsistencies found.

## Language Rules

- All generated content must be in **Brazilian Portuguese (pt-BR)**
- Technical terms in English: cache, timeout, handler, endpoint, state machine, request, response
- Code identifiers and field names stay in English
- Gherkin keywords in Portuguese: `Cenario`, `DADO`, `QUANDO`, `ENTÃO`, `E`, `MAS`
- Story IDs: `STORY-NNN` (English format)

## Sizing Heuristics

**Too big** (split it):
- More than 2 endpoints in one story
- More than 1 protocol flow (e.g., X200 + X420)
- More than 8 Gherkin scenarios
- More than 10 sub-tasks

**Too small** (merge it):
- No testable endpoint or flow
- Less than 2 Gherkin scenarios
- Could be a sub-task of another story

**Just right**:
- 1 clear capability, 4-8 Gherkin scenarios, 4-8 sub-tasks
- Produces testable artifacts (endpoint, handler, migration)

## Common Mistakes

- **Vague data contracts**: "Enviar dados do cartão" is useless. The contract must list every field with type, format, and mandatory flag
- **Abstract Gherkin**: "DADO que o sistema está funcionando" tests nothing. Use concrete preconditions
- **Missing error scenarios**: Every story should have at least 2 error Gherkin scenarios
- **Inconsistent dependencies**: If STORY-003 says "Blocked By: STORY-002" but STORY-002 doesn't list STORY-003 in Blocks, there's a bug
- **Copy-paste from spec without adaptation**: The spec describes the system. The story describes the work. Reframe the spec's content from "the system does X" to "implement X so that Y"
