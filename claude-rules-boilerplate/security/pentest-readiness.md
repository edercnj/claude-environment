# Global Behavior & Language Policy
- **Output Language**: English ONLY. (Mandatory for all responses and internal reasoning).
- **Token Optimization**: Eliminate all greetings, apologies, and conversational fluff. Start responses directly with technical information.
- **Priority**: Maintain 100% fidelity to the technical constraints defined in the original rules below.

# Penetration Testing Readiness — Application Checklist

## Pre-Pentest Hardening

### Minimum Security Posture Before Engaging Pentesters

Complete the following checklist before scheduling a penetration test. Each item prevents common findings that waste pentest budget on known issues.

| # | Control | Status | Priority |
|---|---------|--------|----------|
| 1 | Security headers configured (HSTS, CSP, X-Content-Type-Options, X-Frame-Options) | Required | Critical |
| 2 | TLS 1.2+ enforced, deprecated protocols disabled | Required | Critical |
| 3 | Input validation on all endpoints (allowlist-based) | Required | Critical |
| 4 | Authentication rate limiting and account lockout | Required | Critical |
| 5 | CSRF protection enabled for state-changing operations | Required | High |
| 6 | CORS configuration restricted (no wildcard on authenticated endpoints) | Required | High |
| 7 | Error handling does not expose stack traces or internal details | Required | High |
| 8 | Session management: secure cookies, proper invalidation, timeout | Required | High |
| 9 | Dependency vulnerabilities scanned and critical/high resolved | Required | High |
| 10 | Secrets not exposed in source code, configs, or client-side code | Required | Critical |
| 11 | Admin interfaces not publicly accessible | Required | Critical |
| 12 | Default credentials removed | Required | Critical |
| 13 | Directory listing disabled | Required | Medium |
| 14 | Verbose error messages disabled in production | Required | High |
| 15 | HTTP methods restricted (disable TRACE, OPTIONS where not needed) | Required | Medium |

## Common Findings Prevention

### SQL Injection (SQLi)

**How it is found:** Pentesters inject SQL syntax into input fields, URL parameters, headers, and cookies.

**Prevention:**

```
// REQUIRED: Parameterized queries everywhere
// GOOD
query = "SELECT * FROM users WHERE id = ? AND status = ?"
result = db.execute(query, [userId, status])

// GOOD — ORM with parameterized binding
result = userRepository.findByIdAndStatus(userId, status)

// BAD — String concatenation (WILL be found)
query = "SELECT * FROM users WHERE id = " + userId
result = db.execute(query)

// BAD — String interpolation in query
query = f"SELECT * FROM users WHERE name = '{name}'"
```

**Checklist:**
- All database queries use parameterized statements or ORM
- No string concatenation/interpolation in SQL queries
- Stored procedures use parameterized inputs
- Dynamic query builders use parameterized bindings
- Database user has minimum necessary privileges

### Cross-Site Scripting (XSS)

**How it is found:** Pentesters inject JavaScript into input fields, URL parameters, and stored content.

**Prevention:**

```
// REQUIRED: Context-aware output encoding
// HTML context
output = htmlEncode(userInput)          // &lt;script&gt; instead of <script>

// JavaScript context
output = jsEncode(userInput)            // Unicode escaping

// URL context
output = urlEncode(userInput)           // %3Cscript%3E

// CSS context
output = cssEncode(userInput)           // Hex escaping

// Use templating engines with auto-escaping enabled by default
template.setAutoEscaping(true)          // e.g., Thymeleaf, Jinja2, Handlebars
```

**Checklist:**
- Content-Security-Policy header configured (restrict `script-src`)
- Output encoding applied in all rendering contexts (HTML, JS, URL, CSS)
- Templating engine auto-escaping enabled
- User-generated HTML sanitized with allowlist (e.g., DOMPurify, OWASP Java HTML Sanitizer)
- `HttpOnly` and `Secure` flags on session cookies
- No `eval()`, `innerHTML`, or `document.write()` with user input

### Cross-Site Request Forgery (CSRF)

**How it is found:** Pentesters craft malicious pages that trigger state-changing requests to the application.

**Prevention:**

```
// REQUIRED: CSRF token on all state-changing operations
// Synchronizer Token Pattern
function handleRequest(request):
    if request.method IN ["POST", "PUT", "DELETE", "PATCH"]:
        csrfToken = request.getHeader("X-CSRF-Token")
        sessionToken = session.getCsrfToken()
        if NOT constantTimeEquals(csrfToken, sessionToken):
            throw CsrfException("Invalid CSRF token")

// SameSite cookie attribute (defense-in-depth)
setCookie("session", sessionId, {
    secure: true,
    httpOnly: true,
    sameSite: "Strict"    // or "Lax" for cross-origin GET navigation
})
```

**Checklist:**
- CSRF tokens on all state-changing forms/requests
- `SameSite=Strict` or `SameSite=Lax` on session cookies
- Custom headers required for API requests (e.g., `X-Requested-With`)
- Origin/Referer header validation for critical operations

### Insecure Direct Object Reference (IDOR)

**How it is found:** Pentesters modify resource IDs in URLs and request bodies to access other users' data.

**Prevention:**

```
// REQUIRED: Authorization check on every resource access
function getDocument(documentId, currentUser):
    document = repository.find(documentId)

    // Verify ownership or authorized access
    if document.ownerId != currentUser.id:
        if NOT accessControl.hasAccess(currentUser, document):
            auditLog.warn("IDOR_ATTEMPT", {
                userId: currentUser.id,
                targetResource: documentId,
                targetOwner: document.ownerId
            })
            throw ForbiddenException("Access denied")

    return document

// Use indirect references where possible
function getDocument(index, currentUser):
    // Map user-specific index to actual document ID
    documentId = userDocumentMapping.resolve(currentUser.id, index)
    return repository.find(documentId)
```

**Checklist:**
- Authorization check on every resource access (not just endpoint-level)
- Use UUIDs instead of sequential IDs for resource identifiers
- Implement indirect object references where feasible
- Log and alert on access pattern anomalies (bulk enumeration attempts)

### Mass Assignment

**How it is found:** Pentesters add extra fields to request bodies to modify protected attributes (e.g., `role`, `isAdmin`, `price`).

**Prevention:**

```
// REQUIRED: Explicit field allowlisting
// GOOD — DTO with only allowed fields
class UpdateProfileRequest:
    name: String          // Allowed
    email: String         // Allowed
    phone: String         // Allowed
    // role: NOT included — cannot be mass-assigned
    // isAdmin: NOT included — cannot be mass-assigned

function updateProfile(request, currentUser):
    // Only map allowed fields
    currentUser.name = request.name
    currentUser.email = request.email
    currentUser.phone = request.phone
    repository.save(currentUser)

// BAD — Binding request directly to entity
function updateProfile(request, currentUser):
    objectMapper.updateFromRequest(request, currentUser)  // DANGER: all fields mapped
    repository.save(currentUser)
```

**Checklist:**
- Use DTOs/request objects with explicit field allowlists
- Never bind request body directly to domain entities
- Protect sensitive fields (role, permissions, price, status) from mass assignment
- Framework-level protection configured (e.g., `@JsonIgnoreProperties`, `readonly` fields)

### Server-Side Request Forgery (SSRF)

**How it is found:** Pentesters inject internal URLs or IP addresses into parameters that trigger server-side HTTP requests.

**Prevention:**

```
// REQUIRED: URL validation and network controls
function fetchUrl(url):
    parsed = parseUrl(url)

    // 1. Protocol allowlist
    if parsed.scheme NOT IN ["https"]:
        throw ValidationException("Only HTTPS allowed")

    // 2. Resolve DNS and check IP
    resolvedIp = dns.resolve(parsed.host)
    if isPrivateIp(resolvedIp) OR isLoopback(resolvedIp) OR isLinkLocal(resolvedIp):
        throw ValidationException("Internal addresses not allowed")

    // 3. Domain allowlist (if applicable)
    if DOMAIN_ALLOWLIST_ENABLED AND parsed.host NOT IN allowedDomains:
        throw ValidationException("Domain not in allowlist")

    // 4. Disable redirects (redirects can bypass IP checks)
    response = httpClient.get(url, followRedirects = false, timeout = 5.seconds)

    // 5. Validate response content-type
    if response.contentType NOT IN allowedContentTypes:
        throw ValidationException("Unexpected content type")

    return response

function isPrivateIp(ip):
    return ip.matches("10.0.0.0/8") OR
           ip.matches("172.16.0.0/12") OR
           ip.matches("192.168.0.0/16") OR
           ip.matches("127.0.0.0/8") OR
           ip.matches("169.254.0.0/16") OR
           ip.matches("0.0.0.0/8") OR
           ip.isIpv6LinkLocal()
```

**Checklist:**
- URL scheme validation (HTTPS only)
- DNS resolution to IP, then IP range validation (block private/internal)
- Disable HTTP redirects for server-side requests
- Domain allowlist for external integrations
- Network-level egress controls (firewall rules)

### Rate Limiting

**How it is found:** Pentesters attempt brute force attacks on authentication, API abuse, and resource exhaustion.

**Prevention:**

```
// REQUIRED: Multi-layer rate limiting
rateLimiting:
    global:
        requestsPerSecond: 1000        // Per-service global limit
    perIp:
        requestsPerMinute: 100         // Per IP address
        burstSize: 20
    perUser:
        requestsPerMinute: 60          // Per authenticated user
    perEndpoint:
        "/auth/login":
            requestsPerMinute: 5       // Per IP for login
            lockoutAfter: 5            // Lock after 5 failures
            lockoutDuration: 15m
        "/auth/password-reset":
            requestsPerHour: 3         // Per account
        "/api/search":
            requestsPerMinute: 30      // Per user
        "/api/export":
            requestsPerHour: 5         // Per user
```

**Checklist:**
- Rate limiting on authentication endpoints (login, password reset, MFA)
- Per-IP and per-user rate limiting on all API endpoints
- Account lockout after configurable failed attempts
- Rate limiting on resource-intensive operations (search, export, file upload)
- Return `429 Too Many Requests` with `Retry-After` header

### File Upload

**How it is found:** Pentesters upload malicious files (web shells, polyglots, oversized files) to test upload handling.

**Prevention:**

```
// REQUIRED: Comprehensive file upload validation
function handleUpload(file):
    // 1. Size limit
    if file.size > MAX_UPLOAD_SIZE:
        reject("File exceeds size limit")

    // 2. Content-type validation by magic bytes
    detectedType = detectByMagicBytes(file.content)
    if detectedType NOT IN ALLOWED_TYPES:
        reject("File type not allowed: " + detectedType)

    // 3. Extension validation
    if file.extension NOT IN ALLOWED_EXTENSIONS:
        reject("Extension not allowed")

    // 4. Extension matches content
    if NOT extensionMatchesMime(file.extension, detectedType):
        reject("Extension does not match content type")

    // 5. Antivirus scan
    scanResult = antivirusScanner.scan(file.content)
    if scanResult.isMalicious:
        auditLog.warn("MALICIOUS_UPLOAD", {filename: file.name, threat: scanResult.threat})
        reject("File failed security scan")

    // 6. Strip metadata
    sanitized = metadataStripper.strip(file.content)

    // 7. Store with generated name in non-executable location
    storageName = generateUUID() + "." + safeExtension(detectedType)
    storage.store(sanitized, storageName, {
        contentDisposition: "attachment",   // Force download, never render
        cacheControl: "private, no-cache"
    })
```

**Checklist:**
- File size limits enforced
- Content-type validated by magic bytes, not just extension
- Extension allowlist (not denylist)
- Antivirus/malware scanning on upload
- Files stored outside web root with non-guessable names
- `Content-Disposition: attachment` for downloads
- Metadata stripped (EXIF, etc.)
- No execution permissions on upload directory

## Security Testing Pipeline

### SAST (Static Application Security Testing)

```
// SAST configuration in CI/CD
sast:
    tools: [SonarQube, Semgrep, CodeQL]
    trigger: every-pull-request
    gate:
        critical: 0     // Block merge
        high: 0         // Block merge
        medium: review  // Require review, do not block
    exclusions:
        - test/**       // Test code excluded from gate (but still scanned)
    rules:
        - sql-injection
        - xss
        - path-traversal
        - hardcoded-secrets
        - insecure-crypto
        - command-injection
        - deserialization
```

### DAST (Dynamic Application Security Testing)

```
// DAST configuration
dast:
    tools: [OWASP ZAP, Burp Suite Enterprise]
    trigger: nightly-on-staging
    target: staging-environment
    authentication:
        type: form-based
        credentials: from-vault
    scan-policy:
        - active-scan
        - passive-scan
        - api-scan (OpenAPI spec)
    gate:
        critical: 0     // Block release
        high: review    // Require security review
```

### SCA (Software Composition Analysis)

```
// SCA configuration
sca:
    tools: [Snyk, OWASP Dependency-Check, Trivy]
    trigger: every-pull-request AND daily-schedule
    scope:
        - application-dependencies
        - transitive-dependencies
        - container-base-images
        - OS-packages
    gate:
        critical: block-merge
        high: block-merge
        medium: warn (30-day SLA)
        low: inform (90-day SLA)
    reporting:
        - SBOM generation (CycloneDX or SPDX format)
        - License compliance check
```

### Container Scanning

```
// Container image scanning
container-scanning:
    tools: [Trivy, Snyk Container, Grype]
    trigger: on-image-build AND daily-schedule
    checks:
        - OS vulnerability scan
        - Application dependency scan
        - Dockerfile best practices (Hadolint)
        - Non-root user verification
        - Read-only filesystem compatibility
        - No secrets in image layers
    gate:
        critical: block-deploy
        high: block-deploy
        misconfiguration: block-deploy
```

### Secret Scanning

```
// Secret scanning configuration
secret-scanning:
    tools: [GitLeaks, TruffleHog, detect-secrets]
    trigger: pre-commit-hook AND every-pull-request
    patterns:
        - AWS keys (AKIA...)
        - Private keys (BEGIN RSA/EC/PRIVATE KEY)
        - Database connection strings
        - API tokens and bearer tokens
        - JWT secrets
        - Password patterns
        - Generic high-entropy strings
    gate: block-merge on any finding
    remediation:
        - Rotate compromised secret immediately
        - Remove from git history (BFG Repo-Cleaner or git filter-branch)
        - Add to .gitignore / .gitleaks.toml allowlist only if false positive
```

### Infrastructure Scanning

```
// Infrastructure as Code scanning
infra-scanning:
    tools: [Checkov, tfsec, kube-bench, Trivy Config]
    trigger: every-pull-request (for IaC changes)
    scope:
        - Terraform/CloudFormation/Pulumi configs
        - Kubernetes manifests and Helm charts
        - Docker Compose files
        - CI/CD pipeline configurations
    checks:
        - Encryption at rest enabled
        - Public access restricted
        - Logging enabled
        - Network security groups properly configured
        - IAM policies follow least privilege
        - Container security context configured
    gate:
        critical: block-merge
        high: block-merge
        medium: review
```

## Pentest Scope Configuration

### Scope Definition Template

```
// Pentest scope document template
pentestScope:
    engagement:
        type: "web-application"       // web-application, api, mobile, infrastructure
        methodology: "OWASP WSTG"     // Testing methodology
        duration: "2 weeks"

    inScope:
        applications:
            - name: "Main Web Application"
              url: "https://app.example.com"
              authentication: provided
              roles: ["user", "admin", "api-consumer"]
            - name: "REST API"
              url: "https://api.example.com"
              documentation: "https://api.example.com/docs"
              authentication: "Bearer token"

        testingAreas:
            - Authentication and session management
            - Authorization and access control
            - Input validation and injection
            - Business logic flaws
            - API security
            - File upload/download
            - Cryptographic implementation
            - Error handling and logging

    outOfScope:
        - Third-party services and integrations
        - Denial of Service (DoS) attacks
        - Physical security testing
        - Social engineering
        - Production environment (staging only)

    credentials:
        provided: true
        roles:
            - { role: "standard-user", username: "pentest-user", mfa: "provided" }
            - { role: "admin", username: "pentest-admin", mfa: "provided" }
            - { role: "api-consumer", apiKey: "provided-via-vault" }

    reporting:
        format: "CVSS 3.1 scored findings"
        retestPeriod: "30 days after report delivery"
        communicationChannel: "encrypted-email"
```

## Anti-Patterns (FORBIDDEN)

- Schedule a pentest without completing the pre-pentest hardening checklist
- Use string concatenation for database queries in any part of the application
- Render user input without context-appropriate output encoding
- Skip CSRF protection on state-changing operations
- Allow direct object reference without authorization verification
- Bind request bodies directly to domain entities without field allowlisting
- Allow server-side HTTP requests to internal/private IP ranges
- Deploy without SAST, SCA, and secret scanning in the CI/CD pipeline
- Trust file extensions for upload validation
- Store uploaded files in web-accessible directories with execution permissions
- Skip rate limiting on authentication endpoints
- Run pentests against production environments without explicit authorization
